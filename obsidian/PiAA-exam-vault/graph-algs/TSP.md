# info
1) [algorithm](#algorithm)
	- [brute-force](##brute-force)
	- [branch-and-boundary](##branch-and-boundary)
		- [current-best-bound](###current-best-bound)
		- [MST-bound](###MST-bound)
	- [local-search](##local-search)
		- [2-opt](###2-opt)
		- [simulated-annealing](###simulated-annealing)
	- [2-approximate](##2-approximate)
2) [usage](#usage)
3) [complexity](#complexity)
4) [content](#content)

# algorithm
Задача коммивояжера (TSP problem). NP трудная задача.

**Формулировка:**
Необходимо найти самый выгодный маршрут, проходящий через указанные города ровно по одному разу с последующим возвратом в исходный город.

## brute-force
Полный перебор.

Проблема полного перебора заключается в факториальной сложности алгоритма: на первом шаге выбираем из N городов, на втором - из N-1, ... , на последнем - выбор определен одним оставшимся городом.

Для ускорения работы точного алгоритма используется метод ветвей и границ.

## branch-and-boundary
Метод ветвей и границ.

**Основная идея:**
- Начинаем с любой вершины.
- На каждой итерации дописываем к текущему пути еще одну вершину, в которую мы до этого не заезжали.
- Как только становится ясно, что расширение текущего пути ни к чему хорошему не приведет, перестаем пытаться его расширить.

При расширении текущего пути важно, в какой последовательности перебираются непросмотренные вершины --> на практике имеет смысл идти в ближайшего соседа в первую очередь (т.е. в вершину, в которую попадают по ребру минимального веса).

**Особенности:**
- Основные две эвристики:
	- **Ветви:** в каком порядке перебирать еще не посещенные вершины (например, ближайший сосед).
	- **Границы:** нижняя оценка на длину решения.
- Находит оптимальное решение.
- Время работы зависит и от эвристик, и от входных данных.

### current-best-bound
Использование для границы - стоимость текущего лучшего решения.

**Основная идея:**
Если при добавлении нового пути к текущему, стоимость стала больше, чем стоимость лучшего (на текущий момент) решения, то отсекаем данную ветвь состояний.

![[Pasted image 20250522211931.png]]

### MST-bound
Использование для границы - стоимость минимального остовного дерева.

**Основная идея:**
Если после добавления новой вершины, сумма текущий стоимости и стоимости минимального остовного дерева для оставшихся (неиспользованных) вершин перевалила за текущее лучшее решение, то отсекаем ветвь с этой добавленной вершиной.

**Почему данная оценка работает?**
Результат работы алгоритма коммивояжера - гамильтонов цикл минимальной стоимости (т.е. цикл, проходящий через все вершины по одному разу (кроме начальной)).

Если выкинуть любое одно ребро из этого цикла, то получим остовное дерево для данного графа.

Вес такого дерева будет никак не меньше веса минимального остовного дерева.

**Оценка сложности построения MST:**
- **Краскал:** `O(N*logN)`
- **Прим:** `O(N*logN)` (через бинарную мин-кучу и очередь с приоритетом)

## local-search
Метод локального поиска.

**Основная идея:**
Начинаем с какого-то решения, а далее пытаемся  его локально улучшить.
**Локальное улучшение:** перемещение n ребер в текущем цикле.

**Преимущество:**
Предоставляет большую гибкость по сравнению с методом ветвей и границ: коммивояжер с окнами (в задачах доставки: посещать определенную вершину в определенный временной отрезок).

### 2-opt
Метод 2-окружение.

**Особенность:**
Используем два ребра для перемещения в локальном улучшении.

![[Pasted image 20250525193636.png]]

**Проблема n-окружения:**
По итогу итерационных (локальных) улучшений возможно сваливание в локальный оптимум (минимум), т.е. в решение, которое локальными изменениями улучшить нельзя.

Никто не гарантирует, что данный локальный оптимум имеет какое-либо отношение к глобальному.

### simulated-annealing
Метод имитации отжига.

**Особенность:**
В отличие от 2-окружения позволено иногда ухудшать текущее решение.

```
s <-- какое-нибудь начальное решение
повторять:
	s' <-- случайное решение из окружения s
	delta <-- cost(s') - cost(s)
	если delta < 0:
		заменить s на s'
	иначе:
		заменить s на s' с вероятностью e ^ (-delta / T)
```
Где:
- T - температура (или время), которая (-ое) постепенно растет (т.е. постепенно уменьшаем вероятность ухудшения).

## 2-approximate
Метод 2-приближение. Только для метрического евклидова пространства (иначе не работает правило треугольника).

**Основная идея:**
- Построить минимальное остовное дерево T.
- Продублировать каждое ребро дерева T.
- В полученном графе найти эйлеров цикл.
- Выкинуть из этого цикла все повторения вершин.

![[Pasted image 20250522224730.png]]

**Особенность:**
Не более чем в два раза хуже оптимального решения.

**Доказательство оценки:**
Докажем, что полученное приближенное решение действительно не более чем в два раза хуже оптимального:
- Пусть Wt - вес минимального остовного дерева, а Wopt - вес оптимального гамильтонова цикла.
- Wt <= Wopt (при выкидывания ребра из гамильтонова цикла получается остовное дерево).
- Каждое ребро построенного гамильтонова цикла заменяет какой-то путь эйлерова цикла, длина которого по неравенству треугольника не менее длины этого ребра (при выкидывании ребер из удвоенного минимального остовного дерева итоговый путь (цикл) мог становиться только короче (по правилу треугольника)).
- Значит, длина найденного пути не превосходит 2Wt, а следовательно, и 2Wopt.

# usage
- Задачи логистики.

# complexity
**brute-force:**
- **По времени:** `O(N!)` (описано в методе)
- **По памяти:** `O(N^2)` (хранение матрицы весов)

**brach-and-boundary:**
- **По времени:** `O(N!)` (в самом худшем варианте: когда плохо работают отсечения (при крайне сбалансированном графе))
- **По памяти:** `O(N^2)` (хранение матрицы весов)

**2-opt:**
ДАННУЮ ОЦЕНКУ НЕ ДАВАЛИ
- **По времени:** `O(N^3)` (перебор всех пар ребер - `O(N^2)`, общее число итераций до локального оптимума - `O(N)` (обычно))
- **По памяти:** `O(N^2)` (хранение матрицы весов)

**2-approximate:**
- **По времени:** `O(N*logN)` (построение МОД)
- **По памяти:** `O(N^2)` (хранение матрицы весов)

# content
- [lecture](https://youtu.be/r804FVgvaTo?si=p7zewN3-JrCvdq5H)