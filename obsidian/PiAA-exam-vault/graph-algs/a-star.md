# info
1) [algorithm](#algorithm)
	- [previous-algs](##previous-algs)
		- [bfs](###bfs)
		- [dijkstra](###dijkstra)
			- [dijkstra-potentials](###dijkstra-potentials)
	- [A*](##A*)
		- [way-direction](###way-direction)
		- [heuristic-function](###heuristic-function)
		- [limitations](###limitations)
	- [ALT](##ALT)
	- [REACH](##REACH)
2) [usage](#usage)
3) [complexity](#complexity)
4) [content](#content)

# algorithm
Алгоритм нахождения кратчайшего пути в графе для любых двух пар вершин.

## bfs
Алгоритм нахождения кратчайшего пути в графе через **поиск в ширину**.

**Алгоритм:**
- **Инициализация**:
    - Выбираем начальную вершину.
    - Создаем очередь и добавляем в неё начальную вершину.
    - Помечаем начальную вершину как посещенную.
    - Создаем массив/словарь для хранения посещенных вершин.
    - При необходимости инициализируем структуры для отслеживания расстояний и предшественников.

- **Основной цикл**:
    - Пока очередь не пуста:
        - Извлекаем вершину из начала очереди
        - Обрабатываем извлеченную вершину (выводим, анализируем и т.д.)
        - Находим все смежные вершины:
            - Если соседняя вершина еще не посещена:
                - Помечаем её как посещенную
                - Добавляем её в конец очереди
                - Записываем расстояние (обычно distance\[сосед\] = distance\[текущая\] + 1)
                - Запоминаем предшественника (parent\[сосед\] = текущая)

- **Восстановление пути** (опционально):
    - Используя массив предшественников, восстанавливаем путь от конечной до начальной вершины

За счет такого послойного обхода, BFS гарантирует нахождение пути с наименьшим количеством рёбер.

**Проблема bfs:**
Стандартный поиск в ширину (BFS) **не подходит** для поиска кратчайшего пути в взвешенном графе, так как он находит путь с минимальным количеством рёбер, а не минимальной суммарной весовой стоимостью.

BFS исследует граф по "уровням удаленности" от начальной вершины, что работает только когда все ребра имеют одинаковый вес. В взвешенном графе путь с большим количеством рёбер может иметь меньшую суммарную стоимость.

### dijkstra
**Алгоритм Дейкстры** для взвешенных графов с неотрицательными весами.

В ориентированном взвешенном графе `G`, **вес ребер которого неотрицателен** и определяется весовой функцией `w: E --> R`, алгоритм Дейкстры находит длины кратчайших путей из заданной вершины `s` до всех остальных.

**Алгоритм:**
В алгоритме поддерживается множество просмотренных вершин `U`, для  которых уже вычислены  длины путей до них из `s`. 
- На каждой итерации цикла выбирается вершина `u not in U`, которой на текущий момент соответствует минимальная оценка кратчайшего пути.
- Вершина `u` добавляется в множество `U` и производится релаксация всех исходящих из нее ребер.

```
func dijkstra(s):
    for v in V                    
        d[v] = inf
        used[v] = false
    d[s] = 0
    for i in V
        v = null
        for j in V    // найдём вершину с минимальным расстоянием
            if !used[j] and (v == null or d[j] < d[v])
                v = j
        if d[v] == inf
            break
        used[v] = true
        for e : v.out // произведём релаксацию по всем рёбрам, исходящим из v
            if d[v] + e.len < d[e.to]
                d[e.to] = d[v] + e.len
```

**Пошаговое описание:**
- **Инициализация:** инициализируем массив расстояний до вершин: каждая ячейка кроме той, что отвечает за начальную вершину, принимает значение `inf`.
- **Итерируемся:** проходим по массиву вершин графа `G`: для каждой текущей вершины `i` находим такую не посещенную вершину  `j`, расстояние до которой от `i` минимально.
- **Релаксация:** производим переоценку расстояний от найденной вершины.

**Релаксация ребра:** процесс обновления оценки кратчайшего пути до вершины, если был найден более короткий путь через другую вершину.
```
если d[v] > d[u] + w(u,v), то:
    d[v] = d[u] + w(u,v)
    предшественник[v] = u
```

Алгоритм Дейкстры перечисляет вершины в порядке возрастания расстояния до них от стартовой вершины. 

Следовательно, Дейкстру можно представить геометрически: вершины поместить на плоскость: при добавлении пути до новой вершины, радиус просмотренных вершин увеличивается.
![[Pasted image 20250607135343.png]]

**Оптимизация:**
Алгоритм Дейкстры считает минимальные расстояния от текущей вершины до всех остальных, что излишне для задачи поиска минимального пути в графе для каких-то определенных вершин.

Следовательно, можно придумать следующие оптимизации:
- Остановка Дейкстры по достижению пути из вершины `s` до вершины `t`.
- Запуск Дейкстры с двух направлений: и из `s`, и из `t`.

### dijkstra-potentials
Дейкстра с потенциалами.

Если в взвешенном графе, для которого мы хотим применить алгоритм Дейкстры присутствуют отрицательные веса, то мы должны заменить все длины ребер на другие: на неотрицательные.

**Как заменить ребра?**
Длины должны быть неотрицательными и быть сопоставимыми с теми, что были в предыдущем графе.

Т.е. должны обладать **свойством**: 
Допустим, что в изначальном графе `G` существовал кратчайший путь `p`. Тогда при перевзвешивании ребер, данный путь `p'` (после перевзвешивания) должен остаться кратчайшим в графе `G'`.

Для такого преобразования вводят: 
- **Потенциал** `phi` для каждой вершины: некоторое число, присущее каждой вершине.
- **Длины** ребер **преобразуются** по следующему правилу: `l'(u, v) = l(u, v) + phi(u) - phi(v)`.

Данное правило оставит `p'` самым дешевым путем в графе `G'`. 

**Доказательство:**
Для каждой вершины на пути `p'` мы должны войти и выйти из нее. Тогда:

Пусть `u = s_0` и `v = s_k`, следовательно:
`l'(s_0, s_k) = l'(s_0, s_1) + l'(s_1, s_2) + ... + l'(s_k-1, s_k) = l(s_0, s_1) +  phi(s_0) - phi(s_1) + l(s_1, s_2) + phi(s_1) - phi(s_2) + ... + l(s_k-1, s_k) + phi(s_k-1) - phi(s_k) = l(s_0, s_k) + phi(s_0) - phi(s_k)`

Т.е. длина пути измениться на константу для любого пути из `u` в `v`, ч.т.д.

**Важное уточнение:** чтобы была возможно выбрать неотрицательные потенциалы для каждой из вершин, необходимо отсутствие отрицательных циклов (т.к. для любого цикла `l'(x, x) = l(x, x)` (потенциалы уничтожаются) (т.е. в отрицательных циклах останутся отрицательные ребра)).

## A*
Алгоритм A*. Эвристический алгоритм (но в евклидовом пространстве гарантирует оптимальное решение (т.к. все ребра станут неотрицательными)).

**Отличие от Дейкстры:** движение в направлении цели. Т.е. основываемся на идее, что для каждой вершины можно назвать оценку расстояния до конечной вершины.

Например: `phi(v)` - евклидово расстояние до конечной вершины `t`.

**Требование к потенциалу:**
- **Допустимость:** `phi(v) <= d(v, t)`.
- **Монотонность:** `phi(u) <= l(u, v) + phi(v)` (т.е. разность потенциалов инцидентных вершин не превышает вес ребра, соединяющее эти вершины).

Если потенциальная функция обладает **допустимостью** и **монотонностью**, то **A\*** гарантированно  оптимален.

**Шаги алгоритма:**
- Перевзвешиваем граф по потенциальной функции `phi` и правилу `l'(u, v) = l(u, v) - phi(u) + phi(v)` (по правилу треугольника (для евклидово случая) `l(u, v) + dist_eucl(v, t) >= dist_eucl(u, t)`).
- На каждой итерации выбираем такую вершину `v`, что минимизирует `l'(s, v)`: т.е. выбираем такую `v`, для которой `phi(v)` минимально.

### way-direction
Выбор направления пути Дейкстрой при 0-взвешивании рёбер оптимального пути.

Если за потенциальную функцию взять: `phi(v) = dist(v, t)`, где `dist(v, t)` - оценка пути от вершины `v` до вершины `t`, то:

Если ребро `u-v` содержится в оптимальном пути `s-->t`: `dist(u, t) = l(u, v) + dist(v, t)`. После переназначения веса по правилу: `l'(u, v) = l(u, v) - phi(u) + phi(v)`, получаем: `dist(u, t) = l'(u, v) + phi(u) - phi(v) + dist(v, t)`.

Следовательно, `l'(u, v) = dist(u, t) - dist(u, t) + dist(v, t) - dist(v, t) = 0`.

Если `dist(a, b)` - точная оценка расстояния, то:
- Любое ребро, что содержится в оптимальном пути, после переназначения веса будет весить `0`.
- Следовательно, если на переназначенном графе `G'` запустить Дейкстру, то поиск будет осуществляться по пути нулевого веса: Дейкстра не будет растекаться в бок.

### heuristic-function
Доказательство неизменности пути при перевзвешивании рёбер.

Аналогично [Дейкстре с потенциалами](###dijkstra-potentials). Просто расписываем весь путь и получаем, что длина каждого пути изменилась на константу, которая зависит от начальной и конечной вершин --> наименьший путь остался наименьшим.

### limitations
**Ограничения A\*:**
- Работает быстро, если потенциальная функция хорошая и приближает расстояние до цели.
- Неэффективен без подходящей эвристики.
- Не в евклидовом пространстве переоценка весов графа может давать отрицательные ребра --> Дейкстра не заработает.

## ALT
Улучшенный A\*.

Если граф не в евклидовом пространстве --> невозможно дать оценку в соответствии с евклидовом расстоянием. Тогда чтобы длины ребер после перевзвешивания стали неотрицательными нужно выбрать некоторое число вершин-маяков.

Вершины-маяки должны:
- Быть в небольшом количестве (т.к. перед совершением действий с вершиной необходимо будет посмотреть на маяки).
- Должны быть распределены по графу: они не должны находится близко друг к другу.

Для каждого маяка вычислим расстояние от каждой вершины до него, и сохраняем эти сведения (оценка по времени на препроцессинг: `O(|L|*|V|)`, где `|L|` - число маяков).

Тогда, используя неравенство треугольника, можно получить: `d(v, t) + d(t, l) >= d(v, l)`, где `l` - маяк.

Т.к. `d(t, l)` и `d(v, l)` уже предподсчитаны, то: `d(v, t) >= d(v, l) - d(t, l)` (оценка снизу).

Итог: `phi(v) = max{d(v, l) - d(t, l)}` по всем `l` из `L`.

После такого предподсчета, алгоритм A\* будет работать правильно. 

## REACH
Улучшенный A\*.

Вводится численная характеристика вершины - её reach (достижимость). Она измеряет, насколько "центральна" вершина для всех кратчайших путей (насколько часто данная вершина находится в каком-либо из кратчайших путей (аналогия с мостами)).

Пусть `P` - какой-то кратчайший путь, `r(v, P)` - функция reach, тогда: ``
- `r(v, P) = min{dist(s, v), dist(v, t)}` - по отношению к конкретному оптимальному пути `P`.
- `r(v) = max{r(v, P)}` - по отношению к графу `G`, т.е. по отношению ко всем оптимальным путям (максимум по всем `P`).

При поиске пути из `s` в `t`, если `reach(v) < min(d(s, v), d(v, t))`, то `v` точно не лежит на кратчайшем пути - её можно отбросить.

# usage
- Навигация.

# complexity
Для  алгоритмов **A\***, **ALT**, **REACH** оценка складывается из препроцессинга и самой  работы алгоритма.

**bfs:**
- **По времени:** `O(|V| + |E|)` (каждую вершину мы посещаем ровно один раз. Для каждой вершины мы просматриваем все смежные с ней рёбра)
- **По памяти:** `O(|V|)` (храним очередь вершин для обхода (в худшем случае может содержать все вершины))

**dijkstra:**
- **По времени:** `O(|V|^2)` (цикл по всем вершинам (`O(|V|)`), поиск минимума (`O(V)`), релаксация (`O(E)`, но `E <= |V|^2`))
- **По памяти:** `O(V)` (хранение массивов вершин и стоимостей)

**A\*:**
- **По времени:** `O(|V|^2)` + `O(|V|)` (в худшем случае `phi(u) = 0`) `O(|V|)` + `O(|V|)` (в лучшем случае `l'(u, v) = 0`, если ребро в оптимальном пути)
- **По памяти:** `O(|V| + |V|)` (как у Дейкстры + хранение потенциалов).

**ALT:**
ОЦЕНКУ НЕ ДАВАЛИ
- **По времени:** `O(|V|)` + `O(|L|*|V|)` (`O(|L|*|V|)` - препроцессинг)
- **По памяти:** `O(|V| + |L|*|V|)` (`O(|L|*|V|)` - хранение для маяков)

**REACH:**
ОЦЕНКУ НЕ ДАВАЛИ
- **По времени:** `O(|V|)` + `O(сложно)`
- **По памяти:** `O(|V| + |V|)` (хранение всех вершин + хранение `reach`)

# content
- [dijkstra](https://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%94%D0%B5%D0%B9%D0%BA%D1%81%D1%82%D1%80%D1%8B)
- [lecture](https://youtu.be/JUqeFV__fSA?si=cDVVpL6dsXHiKwrd)