# info
1) [algorithm](#algorithm)
	- [karger-algorithm](##karger-algorithm)
	- [stein-optimization](##stein-optimization)
2) [usage](#usage)
3) [complexity](#complexity)
4) [content](#content)

# algorithm
Задача нахождения минимального разреза графа.

**Формулировка:**
Минимальное число ребер, которые надо удалить, чтобы увеличить количество компонент связности.

## karger-algorithm
Алгоритм Каргера. Вероятностный алгоритм: случайным образом стягиваем ребра.

**Основная идея:**
Стягивание ребер до тех пор, пока не останутся две вершины. Тогда в минимальный разрез войдут те ребра, что соединяют последние две вершины.
**Стягивание ребра:** операция, которая удаляет ребро из графа, а до этого связанные вершины сливаются в одну.

В связи со случайным выбором ребер для стягивания, вполне вероятно, что в процессе работы алгоритма стянутое ребро находилось бы в минимальном разрезе, т.е. что было стянуто важное ребро.

**Вероятность успеха:** `2 / (N ^ 2)` (при единственном запуске).

**Доказательство вероятности:**
Введем обозначения: 
- |V| = n - число вершин в графе.
- |E| = e - число ребер в графе.
- |C| = k - число ребер в минимальном разрезе.

Тогда `P1{Стянутое ребро было в разрезе} = |C| / |E|`.

Заметим, что размер минимального разреза совпадает с минимальной степенью вершины в графе (иначе можно просто эту вершину отсечь, тем самым увеличить количество компонент связности).

Тогда `|E| >= (|V| * |C|) / 2` (т.к. по т. Эйлера `|E| = 0.5 * sum(deg|v|)`, а `|C| <= deg(v)` для любой вершины).

Следовательно, `P1 = |C| / |E| <= |C| / ((|V| * |C|) * 0.5) = 2 / n`.
Получаем, что `P2{Стянутое ребро не в разрезе} = 1 - P1 = (n - 2) / n`.
Итог, `P3{все стянутые ребра не в разрезе} = ((n - 2) / n) * ((n - 1 - 2) / (n - 1)) * ... * ((n - (n-2)) / (n - (n - 4))) * ((n - (n - 1)) / (n - (n - 3))) = 2 / (n * (n - 1))` (в последний раз стягиваем ребро, когда осталось три вершины). 

Таким образом, `P3 = 2 / (n * (n - 1)) ~= 2 / (n^2)`, ч.т.д.

**Множественный  запуск:**
Допустим, алгоритм был запущен `n^2` раз, тогда: `P1{все хорошо} = 1 - P2{все плохо} ^ (n^2) = 1 - (1 - (2/(n^2))) ^ (n^2)`
Итог, `P1 = 1 - (1 - (2 / (n^2)) ^ (n^2)`.

**Оценка сложности:**
- **Стягивание:** `O(N)` (так как требуется обновить одну строку и один столбец матрицы).
- **Одна итерация:** `O(N^2)` (необходимо стянуть `N` вершин).
- **Множество итераций:** `O(N^4)` (если прогнать алгоритм `N^2` раз).

## stein-optimization
Оптимизация Штейна для алгоритма Каргера.

**Основная идея:**
В алгоритме Каргера бралось случайное ребро на стягивание. Причем вероятность выбора плохого ребра на стягивание (т.е. того, что в мин. разрезе) в начале много меньше вероятности выбора такого ребра в конце.

Алгоритм оптимизации Штейна предлагает запоминать точки с номером `(1 - 1 / sqrt(2)) * n`. Т.к. вероятность выбора плохого ребра вслед за тем, что имеет такой номер > 50%.

**Вероятность успеха:** `1 / log(v)`

**Оценка сложности:**
- **Одна итерация:** `T(V) = V^2 + 2 * T(V / sqrt(2)) = V^2 + ... = V^2 * log(V)`
- **Множество итераций:** `(V^2 * log(V)) * log(V) = V^2 * log^2(V)`

# usage
- Сетевые задачи: проверка, насколько сеть устойчива (что сеть останется связной).
- Кластеризация.
- Карты: ГИС (при увеличение и уменьшение масштаба определяет наиболее значимые рельефы).

# complexity
**karger-algorithm:**
- **По времени:** `O(N^4)` (если прогнать алгоритм `N^2` раз)
- **По памяти:** `O(N)` (для хранения графа из `N` вершин)

**stein-optimization:**
- **По времени:** `O(N^2 * log^2(N))` (если прогнать алгоритм )
- **По памяти:** `O(N)` (для хранения графа из `N` вершин)

# content
- [book](https://se.moevm.info/lib/exe/fetch.php/courses:algorithms_building_and_analysis:min-cut-itmo.pdf)