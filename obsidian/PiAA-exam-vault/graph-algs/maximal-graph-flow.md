# info
1) [algorithm](#algorithm)
	- [ford-fulkerson-alg](##ford-fulkerson-alg)
		- [residual-network](###residual-network)
		- [complementary-path](###complementary-path)
		- [reverse-edges](###reverse-edges)
	- [goldberg-alg](##goldberg-alg)
		- [pre-flow](###pre-flow)
		- [height-function](###height-function)
		- [push-ralabel](###push-ralabel)
		- [correctness](###correctness)
2) [usage](#usage)
3) [complexity](#complexity)
4) [content](#content)

# algorithm
Задача нахождения максимального потока в сети.

Дан взвешенный ориентированный граф `G` с вершинами `s` - сток, `t` - исток. Требуется найти максимальный поток в графе.

**Исток** - вершина только с исходящими ребрами.
**Сток** - вершина только со входящими ребрами.

**Пропускная способность** - `c(A, D)` (`capacity`).
**Текущий поток** - `f(A, D)` (`flow`).
**Максимальный поток** - `F(A, D)`.

**Остаточная сеть** - `G` - граф с неиспользованными на данный момент ребрами.
**Дополняющий путь** - путь из `s` в `t`, по которому можно еще что-то пропустить.
**Обратное ребро** - это ребро, добавляемое в остаточную сеть в направлении, противоположном исходному ребру, с пропускной способностью, равной текущему потоку по исходному ребру.

**Ограничения на максимальный поток:**
Максимальный поток не может быть больше минимума из веса ребер, исходящих из истока и входящих в сток.

## ford-fulkerson-alg
Алгоритм Форда-Фалкерсона.

**Основная идея:** итеративно увеличивать поток, пока существуют пути (дополняющие пути), по которым можно пустить дополнительный поток от истока к стоку.

**Шаги алгоритма:**
- **Инициализация**:
    - Устанавливаем нулевой поток `F` для всех рёбер.
- **Основной цикл**:
    - Пока существует дополняющий путь в остаточной сети:
        - Находим дополняющий путь.
        - Определяем минимальную пропускную способность на этом пути.
        - Увеличиваем поток вдоль этого пути.
- **Завершение**:
    - Когда больше нет дополняющих путей, текущий поток является максимальным.

### residual-network
Остаточная сеть.

Сеть с ребрами, у которых ненулевая остаточная пропускная способность.

**Построение:**
- Для каждого ребра `(u,v)` с пропускной способностью `c(u,v)` и текущим потоком `f(u,v)`:    
    - Добавляем **прямое ребро** `(u,v)` с остаточной пропускной способностью `c(u,v) - f(u,v)`.
    - Добавляем **обратное ребро** `(v,u)` с пропускной способностью `f(u,v)`.
- Удаляем рёбра с нулевой остаточной пропускной способностью

**Использование:**
- Представляет возможности для изменения текущего потока.
- Позволяет алгоритмам "видеть", где поток можно увеличить или перенаправить.
- Поиск в остаточной сети проще, чем непосредственный анализ исходной сети.

### complementary-path
Дополняющий путь.

Простой путь от истока `s` до стока `t` в остаточной сети.

**Свойства:**
- Каждое ребро на этом пути имеет положительную остаточную пропускную способность.
- Минимальная остаточная пропускная способность на этом пути определяет, на сколько можно увеличить поток.
- Может включать как прямые, так и обратные рёбра.

**Использование:**
- Находим дополняющий путь в остаточной сети.
- Определяем минимальную остаточную пропускную способность на пути (обозначим как `f'`).
- Увеличиваем поток на `f'` по каждому ребру дополняющего пути:
    - Для прямых рёбер `(u,v)`: увеличиваем `f(u,v)` на `f'`.
    - Для обратных рёбер `(v,u)`: уменьшаем `f(u,v)` на `f'`.

### reverse-edges
Обратное ребро.

Ребро, добавляемое в остаточную сеть в направлении, противоположном исходному ребру, с пропускной способностью, равной текущему потоку по исходному ребру.

**Построение:**
- **В исходной сети:**
    - Есть направленное ребро `(u, v)` с пропускной способностью `c(u,v)`.
    - По ребру протекает поток `f(u,v)`, где `0 <= f(u,v) <= c(u,v)`.

- **В остаточной сети:**
    - Прямое ребро `(u,v)` имеет остаточную пропускную способность `c(u,v) - f(u,v)`.
    - Добавляется обратное ребро `(v,u)` с пропускной способностью `f(u,v)`.

**Свойства:**
Обратные рёбра позволяют:
- "Отменить" решения по распределению потока, принятые ранее.
- Перенаправить поток для нахождения более оптимального решения.

## goldberg-alg
Алгоритм Голдберга.

**Основная идея:** использование предпотока: `f: V x V --> R`, т.е.:
- Сделать начальную разметку потока: впускаем в вершины возможно большее число потока, чем они могут потребить (вывести).
- Избытки оставшегося в вершинах потока пытаться сбалансировать за счет каких-то операций (поднять вершину на высоту, чтобы слить излишки).

**Избыток** - `e(u)` - степень переполненности вершины: часть потока в вершине, что не может быть обработана выходящими ребрами (из-за недостатка пропускной способности).

**Шаги алгоритма:**
- Инициализация высот у вершин: у всех вершин, кроме `s` нулевая высота. Из истока проводим все выходящие ребра.
- На каждой итерации цикла в произвольном порядке применяем операции **push** и **relabel**.
- Если на каком-то шаге цикла невозможно применить операции, то максимальный поток найден, причем он равен тому предпотоку, который получили на последней итерации цикла.

### pre-flow
Функция предпотока.

Обобщение понятия потока, которое допускает нарушение закона сохранения потока в промежуточных вершинах (т.е. может втекать в вершину больше, чем вытекать). 

**Отличие от обычного потока:**
- **В обычном потоке:** для каждой вершины (кроме истока и стока) количество входящего потока не больше количества выходящего.
- **В предпотоке:** для каждой вершины (кроме истока и стока) количество входящего потока может превышать количество выходящего (т.е. в вершине могут накапливаться избытки).

**Формальное определение:**
**Предпоток** - функция  `f: V x V --> R`.

Функция предпотока f должна удовлетворять следующим условиям:
- **Кососимметричность:** поток, который был послан по ребру, можно на каком-то шаге алгоритма послать обратно.
- **Избыточность:** часть входящего потока может накапливаться в вершине (когда количество входящего потока больше количество выходящего).

### height-function
Высотная функция.

**Высотная функция** `h: V --> R` - функция, что сопоставляет каждой вершине определенное число.

**Свойства:**
- `h(s) = |V|` (исток - самая высокая вершина).
- `h(t) = 0` (сток - самая низкая вершина).
- Для любого ребра `(u, v)` из остаточной сети: `h(u) <= h(v) + 1` (т.е. запрещаем прокидывать поток вниз через слой, причем ограничений на рост потока вверх нету).

Т.е. граф взяли, подвесили и разбили на уровни.
### push-ralabel
Идея push-relabel алгоритмов.

Алгоритм нотирует каждую вершину определенным числом (`label`): в зависимости от этого `label`, во время работы алгоритма эти `label` как-то меняются.

В Голдберге `label`'ом считается "высота" вершины в графе.

**Идея push-relabel алгоритмов:** не искать пути целиком от истока к стоку, а локальными операциями постепенно проталкивать поток в направлении стока.

Обратные ребра строим как обычно.

**Основные операции:**
- **Push (Проталкивание):**
	- Применяется к насыщенной вершине `u` и соседней вершине `v`, что на уровень ниже.
	- Перемещает часть или весь избыточный поток из `u` в `v` (`d(u, v) = min{c_f(u, v), e(u)}`, где `c_f(u, v)` - остаточная пропускная способность).
	- **Условия применимости**:
	    - Вершина `u` насыщена `(e(u) > 0)`.
	    - Остаточная пропускная способность `c_f(u,v) > 0`.
	    - Высота `u` больше высоты `v`: `h(u) > h(v)` (т.е. по-сути `h(u) = 1 + h(v)`).
	- **Действия:**
		- Обновление остаточной пропускной способности: `c_f(u, v) = c_f(u, v) - d(u, v)`.
		- Обновления предпотоков: 
			- Для прямого ребра:  `f(u, v) = f(u, v) + d(u, v)`.
			- Для обратного ребра: `f(v, u) = -f(u, v)` (для обратного ребра).
		- Обновления переполненностей:
			- Для вершины `u`: `e(u) = e(u) - d(u, v)`
			- Для вершины `v`: `e(v) = e(v) + d(u, v)`

- **Relabel (Поднятие/Переразметка):**
	- Увеличивает высоту насыщенной вершины.
	- Не нарушает инвариантность по высотам: т.к. вершина `u` поднимается только на единицу по отношению к минимальной  высоте соседа, у которого есть положительная остаточная пропускная способность.
	- **Условия применимости**:
	    - Вершина `u` насыщена (`e(u) > 0`).
	    - Для всех соседей `v` таких, что `c_f(u, v) > 0`, высота `u` не меньше: `h(u) <= h(v)`.
	- **Действие**: `h(u) = 1 + min{h(v) | с_f(u, v) > 0}`.

### correctness
Доказательство корректности.

Докажем, что максимальный поток будет найден на той итерации цикла, когда больше невозможно сделать ни **push**, ни **relabel**. Причем значение максимального потока будет равно тому предпотоку, что получили на этой итерации.

**Доказательство:**
Предпоток - это поток, но с ослаблением: у предпотока могут быть переполненные вершины.

Если невозможно применить ни **push**, ни **relabel**, то у вершин нет переполнений (иначе возможен только один вид переполнений: из истока в инцидентные вершины (но его можно легко убрать)) --> предпоток превратился в поток, т.е. в любую вершину втекает не более, чем вытекает.

Почему данный предпоток стал максимальным потоком?
Вернемся к Форду-Фалкерсону: поток максимальный --> не осталось дополняющих путей.

Т.е. необходимо доказать, что у последнего предпотока нет дополняющего пути.

По инвариантам высот, ребро может идти вниз только, если высота смежных вершин отличается не более чем на единицу. Но если оставался хотя бы один дополняющий путь, то тогда удалось бы построить путь из истока в сток размера `|V| + 1` ребер.

Но длина дополняющего пути - `|V| - 1` --> противоречие.

# usage
- Проверка сетей (транспортных ...) на эффективность.

# complexity
**ford-fulkerson:**
- **По времени:** `O(F*|E|)` (`F` раз, в худшем случае, нужно будет составить дополнительный путь).
- **По памяти:** `O(|V| + |E|)`

**goldberg:**
- **По времени:**
- **По памяти:**

# content
