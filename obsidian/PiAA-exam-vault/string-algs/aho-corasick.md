# info
1) [algorithm](#algorithm)
	- [patterns-matching](##patterns-matching)
	- [trie](##trie)
	- [suffix-link](##suffix-link)
		- [failure-function](###failure-function)
	- [search-algorithm](##search-algorithm)
2) [usage](#usage)
3) [complexity](#complexity)
4) [content](#content)

# algorithm
Алгоритм Ахо-Корасик для поиска набора шаблонов в тексте.

## patterns-matching

**Формулировка:**
Дан текст `T[1:n]` длины `n`, шаблоны `P[k] = {p1, p2, ..., pk}` различной длины: `mi <= n`. Требуется найти все вхождения шаблонов `patterns` в тексте `T[1:n]`.

## trie
Бор, префиксное дерево: древовидная структура данных, которая используется для хранения строк и эффективного поиска по ним.

**Структура:**
- Корень дерева представляет пустую строку
- Путь от корня до любого узла соответствует префиксу некоторой строки
- Узлы могут содержать метки, указывающие на конец слова

**Основные операции:**
- Добавление строки в бор (`O(m)`, где `m` - длина добавляемой строки):
	- Начинаем с корня.
	- Для каждого символа проверяем, существует ли соответствующий потомок.
	- Если потомка нет - создаём новый узел.
	- Переходим к следующему символу.
	- Помечаем последний узел как конец слова.
- Поиск строки в боре: `O(m)`:
	- Начинаем с корня.
	- Для каждого символа проверяем наличие потомка (перехода по ребру).
	- Если потомка нет - строка отсутствует.
	- Если все символы пройдены, проверяем метку конца слова.
- Удаление строки: `O(m)`:
	- Найти узел, соответствующий концу слова.
	- Снять метку конца слова.
	- Удалить ненужные узлы:
		- Начинать с конца удаляемого слова.
		- Проверить, есть ли у текущей вершины потомки:
			- если есть: оставить вершину.
			- иначе: удалить вершину, перейти к родителю, повторить последний пункт удаления.

Две строки в боре имеют общие ребра при условии наличия у них общего префикса. Крайний случай - все строки образцы попарно не имеют одинаковой начальной части. Значит верхняя оценка для числа вершин в боре - сумма длин всех строк + 1 (корень).

## suffix-link
Суффиксальная ссылка.

Необходима для переходов по бору, если текущее состояние продлить не удалось. Таким образом сохраняется часть текущего слова.

**Формальное определение:**
Для узла, соответствующего текущей строке S, суффиксальная ссылка указывает на узел, соответствующий наибольшему **собственному суффиксу** строки S, который также является **префиксом** какого-либо шаблона в боре (но эта вершина может **не соответствовать** концу какого-либо шаблона).

**Способ построения:**
Линейного времени работы построения ссылок можно добиться, если строить их в порядке удаления от корня.
- Для текущей вершины `x` мы знаем значение ссылки ее родителя (она уже была высчитана).
- Тогда откидываем последнюю букву `c` и идем по ссылке: идем по ссылке родителя (по `x.parent.suff_link`).
- В вершине `y = x.parent.sufflink` смотрим: есть ли переход по букве `c`:
	- если есть: `x.suff_link = y.goto(c)`
	- иначе: повторяем переход по ссылке, но уже для `y` (т.е. необходимо перейти в `y.suff_link`), и сравнение.

В конечном случае последний переход по ссылке приведет в корень (т.к. переход уменьшает длину слова хотя бы на единицу).

Если для какой-то вершины `x'` было много откатов (в поисках ссылки), то для потомков `x'` в таком количестве их уже не будет (из-за найденной ссылки для `x'`).

**Проблема ссылок:**
Если в списках шаблона существуют такие, что они содержаться в других, то алгоритм будет работать не совсем оптимально.

Рассмотрим пример:
Набор шаблонов `P={he, shelf, his, him, her, hers}`.
Построенный бор:
![[Pasted image 20250606222236.png]]

Если на вход автомата подается слово `shelf`, то без дополнительных оптимизаций можно пропустить подшаблон `he`.

Оптимизация: для каждой вершины должен быть построен односвязный список шаблонных слов, которые полностью достигаются, если автомат добрался до данной вершины. Должна храниться ссылка, которая начинает односвязный список шаблонов, которые были полностью достигнуты из этой вершины.
![[Pasted image 20250606222607.png]]

Как понять, какие шаблоны заканчиваются в этой вершине?
Это возможно, если шаблон `pi` - суффикс текущего слова `s`. Но если рассмотреть слово по ссылке `s'` для `s`, то `pi` должен быть суффиксом для `s'`. `pi` не может быть длиннее `s'`: иначе ссылка из `s` бы вела в `pi`.

Тогда, пройдя слово `s`, можно найти:
- Само слово `s` в списках шаблонов (это вполне возможно).
- Суффиксы `s`, что есть в шаблонах.

Получаем: 
- Если в текущей вершине `x` - не терминальная, то массив на вывод вхождений шаблонов `out` совпадает с массивом `out` для `x.suff_link`.
- Если  вершина `x` - терминальная, тогда: слова на вывод - слово, заканчивающееся в вершине `x` и массив `out` (отсюда параметр `ans` в сложности).
![[Pasted image 20250606225756.png]]

### failure-function
Функция, что строит схему переходов. Работает на основе префикс-функции.

**Способ использования:**
Если осуществляется переход по ссылке, т.е. продлить текущее состояние не удалось, то: 
- Берем текущее слово `s` из текущего состояния и букву `c`, что пытались присоединить к нему.
- Пытаемся найти такое произвольное слово в боре `s'`, что совпадает с максимальным собственным суффиксом строки `s`.
- Если удалось продлить `s'` путем присоединения к нему символа `c`, то успех.
- Иначе: повторяем алгоритм для `s'`.

Если по итогу работы  алгоритма, длина `s` стала равна нулю, то переход осуществляется в корень.

Т.е. значение **failure-function** - это самый длинный собственный суффикс строки, что присутствует в боре.

**Сложность по времени:**
Осталось объяснить, почему время работы от размера текста остается линейной.

Поместим бор в систему координат: координата - текущая длина произвольного слова в боре.

При добавлении новой буквы, координата может увеличиться максимум на единицу. Следовательно, максимальная координата, что возможна - размер текста. 

Чтобы откатиться по **failure-function**, необходима положительная координата (ниже 0 (корня) откатиться невозможно). Откат по ссылке уменьшит координату в худшем случае на единицу.

Итог:
- Максимальное число возможных подъемов: `|t|`.
- Максимальное число возможных откатов: `|t|`.
- Суммарно: `2|t|` (линейно).

## search-algorithm
Алгоритм поиска.

Для поиска набора шаблонов используется конечный детерминированный автомат: одно входное состояние, одно выходное, рассматривается одно состояние на шаг (переход).

Состояние автомата - текущая вершина (т.е. префикс какого-то шаблона).

Автомат конечен, т.к. нам не следует помнить все буквы, что когда-либо поступали в автомат. Требуется хранить только "полезные": максимальная последовательность, которая хранится в префиксах слов ("нужно помнить ровно столько букв, сколько нам могут пригодиться для чтения одного из интересующих нас слов"). 

Т.е. нужно помнить самый длинный конец прочитанного текста, что является префиксом некоторого `pi`.

На каждой итерации алгоритма происходит переход из одного состояния в другое с помощью входящего символа: 
- Если автомат получает хорошую букву, то продлевается текущее состояние.
- Иначе: заканчиваем текущее состояние и переходим по [ссылке](##suffix-link).

**Итог:** для каждого произвольного слова в боре (т.е. не обязательно того слова, конечная вершина которого - терминальная) необходимо найти самый длинные его конец, что также присутствует в боре (т.е. является префиксом произвольного слова).

Автомат Ахо-Корасик полностью построен, когда построена система переходов.
# usage
- Фильтрация слов.
- Геномы.
- Простой поиск.
# complexity

**aho-corasick:**
- **По времени:** `O(sum(|pi|) + |t| + ans)` (`sum(|pi|)` - сумма длин шаблонов, `|t|` - размер текста, `ans` - число вхождений шаблонов в текст (если текст состоит из `k` повторений единственного шаблона, то придется сделать `k` обходов бора) (для вывода большого числа вхождений тоже нужно время))
- **По памяти:** `O(n*k)` (`n` - число шаблонов, `k` - их средняя длина).

**kmp:**
- **По времени:** `O(sum(|pi|) + k * |t|)` (`k` - число шаблонов)
# content
- [lecture](https://youtu.be/pX4VCKudwYo?si=LTZAdIHaMzuHWjYq)