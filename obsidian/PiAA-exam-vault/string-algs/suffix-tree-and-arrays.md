# info
1) [algorithm](#algorithm)
	- [suffix-tree](##suffix-tree)
	- [suffix-array](##suffix-array)
2) [usage](#usage)
3) [complexity](#complexity)
4) [content](#content)

# algorithm

## suffix-tree
Суффиксные деревья.

Решают задачу поиска неизвестных шаблонов в известном тексте (т.е. на вход был дан только текст (шаблоны "генерируются на лету")).

**Суффиксное дерево** - дерево, содержащее все суффиксы строки.

**Зачем хранить суффиксы?**
Любой шаблон `p` в тексте `T` - это префикс какого-то суффикса.
![[Pasted image 20250606232205.png]]

Суффиксное дерево позволит искать любой шаблон длины `m` за время - `O(m)`.

**Как построить суффиксное дерево?**
- Наивно добавить все суффиксы текста: дорого по памяти (`O(n^2)`, где `n` - размер текста (каждый суффикс (их число - `n`) сопоставим по длине с  длиной текста)).
  ![[Pasted image 20250606233532.png]]
- Сжатое суффиксное дерево: иногда на ребра будут не вершины, а части текста (или сжать еще больше: хранить не остатки строк, а индексы (срез до конца (т.к. суффиксы))) (линейная память - `O(n)`).
  ![[Pasted image 20250606234127.png]]

Для поиска подстрок нужно знать все суффиксы --> существуют неявные (терминальные) вершины (знак `$`). В сжатом дереве можно потерять собственные суффиксы (например `aba`). Решение - добавить искусственную терминальную вершину (`$`), которая будет говорить, что эта вершина - конечная.
![[Pasted image 20250606235427.png]]

**Как осуществляется поиск?**
- Задаем подстроку (например, `cab`)
- Идем по суффиксному дереву, как по бору.

## suffix-array
Суффиксные массивы.

Существует зависимость от размера алфавита (в суффиксных деревьях): в каждой вершине нужно хранить массив размером с алфавит (для корректного перехода).

**Суффиксный массив:** лексикографически отсортированный массив суффиксов.
![[Pasted image 20250607000804.png]]

Суффиксный массив не храниться как массив строк. Он храниться как массив индексов. Они представляют собой идентификатор в массиве суффиксов (опять же их (суффиксы) можно хранить как индексы начала суффикса).

**Как осуществляется поиск?**
- На вход подается шаблон.
- Осуществляем бинарный поиск: по первой букве можно понять, в какой части массива храниться наша строка (первая буква - префикс какого-то суффикса) (отсекаем первую букву на каждой итерации поиска).
- Доходим до финальной строки (итерации бинарного поиска) и сравниваем строку с суффиксом: есть ли префикс в суффиксе == нашей строке.

Итог: логарифмическая сложность поиска: `O(logN)`, где `N` - длина текста.

**Оптимизация поиска:**
Поиск по lcp (largest common prefix) - поиск по наибольшему общему префиксу двух строк: объединить строки в суффиксном массиве по общему префиксу в отдельные группы.

Таким образом, на каждой итерации бинарного поиска можно "откусывать" больше одной буквы: на каждой итерации сравниваем значения lcp с тем значением, что на текущий момент находится в поиске (суффикс шаблона).

Если значения совпадают: успех.
Иначе: неудача.

Такая оптимизация может привести сложность поиска к `O(m)`, где `m` - длина шаблона (но в худшем случае поиск может остаться логарифмическим).
# usage
- Поиск в интернете.

# complexity
**suffix-tree:**
- **По времени:** `O(N + M)` (`N` - построение (длина текста), `M` - длина шаблона, что ищем) (поиск за время - длина шаблона)
- **По памяти:** `O(N)` (`N` - длина текста (но дополнительно в каждой вершине необходимо хранить массив размером с алфавит))

**suffix-array:**
- **По времени:** `O(NlogN + M)` (`NlogN` - построение и сортировка массива, `M` - поиск шаблона (в лучшем случае через lcp))
- **По памяти:** `O(N)` (`N` - длина текста (количество индексов - начала суффиксов текста))

# content
- лекция на мудле.