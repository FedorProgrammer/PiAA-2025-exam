# info
1) [algorithm](#algorithm)
	- [pattern-matching](##pattern-matching)
		- [naive-matching](###naive-matching)
		- [kmp-algorithm](###kmp-algorithm)
	- [prefix-function](##prefix-function)
		- [naive-prefix](###naive-prefix)
		- [linear-time](###linear-time)
2) [usage](#usage)
3) [complexity](#complexity)
4) [content](#content)

# algorithm
Алгоритм Кнута-Морриса-Пратта для нахождения шаблонов в тексте за линейное время. 

## pattern-matching
Задача  нахождения шаблонов в тексте.

**Формулировка:**
Дан текст `T[1:n]` длины `n`, шаблон (pattern) `p[1:m]` длины `m`: `m <= n`. Требуется найти все вхождения шаблона `p[1:m]` в тексте `T[1:n]`.

### naive-matching
Наивный алгоритм поиска.

**Основные шаги:**
- Начинаем с начала текста: прикладываем шаблон к началу текста.
- Далее передвигаемся на один символ вправо, в не зависимости от того, совпала ли часть текста с шаблоном.

**Проблема:** слишком долго (по времени: `O((n - m + 1) * m)`).

### kmp-algorithm
Алгоритм Кнута-Морриса-Прата.

Основное понятие, что используется в алгоритма - понятие префикс-функции.

**Чем полезна префикс-функция:**
Посчитаем массив значений префикс-функции (т.е. префикс-функцию в векторном представлении) для строки `p[1:m]@T[1:n]` (символ `@` - разделяющий: отсутствует в алфавите строк), тогда:

Если в полученном векторе префикс-функции для объединенной строки, в части, что отвечает за текст, найдется значение, равное длине шаблона, то найдется и вхождение шаблона в тексте, заканчивающееся на данном (по индексу) символе.

![[Pasted image 20250604103346.png]]
Для ячеек со значением `m` префикс общей строки длины `m` (по-сути шаблон) будет совпадать с суффиксом подстроки общей строки, заканчивающимся на данном символе. Т.е. найдена подстрока в тексте, что совпадает с шаблоном.

**Подробнее:**
Допустим, что в определенный момент шаблон и кусок из текста совпали на `l` символов: на `l+1` символе произошло расхождение.

На какую величину можно сдвинуть шаблон?

В наивной реализации шаблон сдвигался на один элемент вправо. 

В алгоритме КМП информация о части шаблона сохраняется: на момент несовпадения подстрока `p[1:l]` уже совпала с `T[i-l:i]` (на `i+1` произошло расхождение) --> 
шаблон можно сдвинуть на `l'` символов (вместо одного), если `p[1:l']` - суффикс для `T[1:i+1]`.

![[Pasted image 20250604111340.png]]
Хотелось бы сдвинуть шаблон так, чтобы `i+1` символ текста уже был бы проверен в шаблоне (т.е. зачем сдвигать на один символ, если из-за `i+1` символа текста будет много несовпадений).

## prefix-function
Префикс-функция.

**Скалярное представление:** максимальный размер префикса данной строки, что равен суффиксу данной строки.
**Векторное представление:** набор (вектор) чисел максимальных собственных префикс-суффиксов для подстрок `T[1:i].`

**Подстрока** - непустая связная часть строки: `1 <= i <= j <= n`, где: `1` - начало строки, `i` - начало подстроки, `j` - конец подстроки, `n` - конец строки.

**Префикс** - подстрока, начало которой совпадает с началом строки.
**Суффикс** - подстрока, конец которой совпадает с концом строки.
**Собственный префикс / суффикс** - префикс / суффикс, длина которого меньше длины строки.

**Примеры:**
- `P(aba, 3) = 1`
- `P(abracadabra, 11) = 4`

**Свойства:**
Пусть `P(T, i) = k`, тогда:
- Если `T[i + 1] == T[k + 1]`, то `P(T, i + 1) = k + 1` (т.е. мы продолжили предыдущий префикс)
- `T[1:P(T, k)]` - префикс-суффикс строки `T[1:i]`

### naive-prefix
Наивный алгоритм вычисления префикс-функции.


# usage
- Поисковики.
- Биологи (геном).

# complexity
**naive-mathcing:**
- **По времени:** `O(m * (n - m + 1))` (`n - m + 1` мест в тексте,  куда можно приложить шаблон размера  `m`)
- **По памяти:** `O(n + m)` (`n` - длина текста, `m` - шаблона)

**kmp-algorithm:**
- **По времени:**
- **По памяти:**

# content
- [lection](https://youtu.be/kIsPv5XRJgU?si=Tc1SeDQVnSJiJTS0)