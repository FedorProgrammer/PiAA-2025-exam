# info
1) [algorithm](#algorithm)
	- [pattern-matching](##pattern-matching)
		- [naive-matching](###naive-matching)
		- [kmp-algorithm](###kmp-algorithm)
	- [prefix-function](##prefix-function)
		- [naive-prefix](###naive-prefix)
		- [linear-time](###linear-time)
2) [usage](#usage)
3) [complexity](#complexity)
4) [content](#content)

# algorithm
Алгоритм Кнута-Морриса-Пратта для нахождения шаблонов в тексте за линейное время. 

## pattern-matching
Задача  нахождения шаблонов в тексте.

**Формулировка:**
Дан текст `T[1:n]` длины `n`, шаблон (pattern) `p[1:m]` длины `m`: `m <= n`. Требуется найти все вхождения шаблона `p[1:m]` в тексте `T[1:n]`.

### naive-matching
Наивный алгоритм поиска.

**Основные шаги:**
- Начинаем с начала текста: прикладываем шаблон к началу текста.
- Далее передвигаемся на один символ вправо, в не зависимости от того, совпала ли часть текста с шаблоном.

**Проблема:** слишком долго (по времени: `O((n - m + 1) * m)`).

### kmp-algorithm
Алгоритм Кнута-Морриса-Прата.

**Шаги алгоритма:**
- Соединить шаблон `p` и текст `T` в одну большую строку. В месте конкатенации поставить символ, что не содержится в алфавитах строк.
- Для строки `p[1:m]@T[1:n]` посчитать массив значений длин префикс-функции `PFL`.
- Обойти массив `PFL`: если в `i`-ой ячейки массива значение совпадает с длиной шаблона, то на индексе `i-(m+1)` (т.к. длина `p[1:m]@T[1:n]` равняется `m + n + 1`) текста **заканчивается** вхождение шаблона в текст.

**Оптимизация по памяти:**
- Не соединять строки в `p[1:m]@T[1:n]`, а посчитать массив значений длин префикс-функции `PFL` для шаблона `p[1:m]`.
- Пройтись по тексту `T`: для каждой подстроки `T[1..i]` (`i` - индекс текущего символа в тексте) посчитать значение `l` - максимальной длины префикса `p[1:m]`, что является суффиксом `T[1..i]`: 
	- При **совпадении** текущих символов текста и шаблона: инкрементировать `l`.
	- При **несовпадении:** сдвигать место приложения шаблона в тексте, т.е. уменьшать `l` (находить `l'` ..., далее описано подробнее).
- Если `l == m`, то вхождение шаблона найдено.

**Подробнее (без оптимизации):**
Посчитаем массив значений длин префикс-функции для строки `p[1:m]@T[1:n]` (символ `@` - разделяющий: отсутствует в алфавите строк), тогда:

Если в полученном векторе префикс-функции для `p[1:m]@T[1:n]`, в части, что отвечает за текст, найдется значение равное длине шаблона, то это - место конца вхождения шаблона в тексте.
![[Pasted image 20250604103346.png]]
Для ячеек со значением `m` префикс общей строки длины `m` (по-сути шаблон) будет совпадать с суффиксом подстроки `p[1:m]@T[1:n]`, заканчивающимся на данном символе. Т.е. найдена подстрока в тексте, что совпадает с шаблоном.

**Итог:**
Весь алгоритм свелся к следующим действиям:
- Объединение `p[1:m]` и `T[1:n]` в `p[1:m]@T[1:n]`.
- Подсчет массива значений длин префикс-функции `PFL`.
- Обход массива `PFL` с фиксацией значений: если `PFL[i] == m`, то `i-(2*m+1)` - **начало** вхождения шаблона в тексте.

**Подробнее (с оптимизацией):**
Допустим, что в определенный момент шаблон и кусок из текста совпали на `l` символов: на `l+1` символе шаблона произошло расхождение.

На какую величину можно сдвинуть шаблон?

В **наивной реализации** шаблон сдвигался на один элемент вправо. 

В **алгоритме КМП** информация о части шаблона сохраняется: на момент несовпадения подстрока `p[1:l]` уже совпала с `T[i-l:i]` (на `i+1` произошло расхождение) --> 
шаблон можно сдвинуть на `l'` символов (вместо одного), если `p[1:l']` - суффикс для `T[1:i+1]` (ищем такое максимальное  `l'`, чтобы не пропустить вхождения).
![[Pasted image 20250604200942.png]]
Т.е. для смещения куска шаблона в тексте более чем на один символ, необходимо:
- Найти префикс-суффикс `p[1:l'-1]` куска `p[1:l]`.
- Убедиться, что символ на месте `p[l']` совпал с `T[i+1]`. 

Значит нужно перебрать все префикс-суффиксы для `p[1:l]` (чтобы затем выбрать максимальный, подходящий).

**Итог:**
Весь алгоритм свелся к следующим действиям:
- Подсчет вектора значений длин префикс-функции `PFL` шаблона `p[1:m]`.
- Проход по тексту `T[1:n]` ("накладываем" шаблон на текст): 
	- Завести переменную `l`, отвечающую за текущее количество символов, что совпали у текущего куска текста и шаблона.
	- Если текущие символы `p[l]` и `T[i]` **совпали**: инкрементировать `l` (продлить наложение шаблона).
	- Если **не совпали:** сдвинуть место наложения шаблона в тексте: 
		- вычислить (точнее взять из `PFL`) длину значения префикс-функции равное `l'-1` для текущего куска `p[1:l]`;
		- убедиться, что `p[l'] == T[i+1]`: если так, то  сдвинуть указатель в шаблоне на индекс `l'`, иначе: вычислить префикс-суффикс для `p[1:l'-1]` (опять же, взять из `PFL`);

## prefix-function
Префикс-функция.

**Подстрока** - непустая связная часть строки: `1 <= i <= j <= n`, где: `1` - начало строки, `i` - начало подстроки, `j` - конец подстроки, `n` - конец строки.

**Префикс** - подстрока, начало которой совпадает с началом строки.
**Суффикс** - подстрока, конец которой совпадает с концом строки.
**Собственный префикс / суффикс** - префикс / суффикс, длина которого меньше длины строки.

**Примеры:**
- `P(aba) = a`
- `P(abracadabra) = abra`
- `P(ab) = eps` (пустая строка)

**Лемма**
Перебирая префикс-суффикс для префикса-суффикса (и т.д.) можно перебрать все префикс-суффиксы для строки `s`. Т.е. множество `A = {P(s), P(P(s)), ... , eps}` - множество всех префикс-суффиксов для строки `s`, где `eps` - пустая строка.
**Доказательство:**
Пусть дана строка `s`. Тогда:
- `P(s)` - префикс-суффикс для строки `s`.
- `P(P(s))` - префикс-суффикс для строки `P(s)`: но т.к. сам `P(s)` - префикс-суффикс для `s`, то `P(P(s))` тоже будет им (можно будет выделить префикс `P(P(s))` в строке `s`, что будет совпадать с суффиксом для `P(s)`, но `P(s)` совпадает с суффиксом для `s` --> `P(P(s))` - префикс-суффикс для `s`).
- `...` (аналогично для остальных)
- `eps`:  переход к пустой строке осуществим, т.к. операция взятия префикса-суффикса уменьшает входную строку.

Докажем, что действительно выражены все префикс-суффиксы:

Если на каком-то моменте появился еще один префикс-суффикс `P(P(P(s)))*`, например: между `P(P(s))` и `P(P(P(s)))`, то: 
- `P(P(P(s)))*` - префикс-суффикс для строки `P(P(s))`.
- Длина `P(P(P(s)))*` больше длины `P(P(P(s)))` (т.к. находится между `P(P(s))` и `P(P(P(s)))`).

Значит, `P(P(P(s)))*` - истинный префикс-суффикс для `P(P(s))` (т.е. он должен быть на месте `P(P(P(s)))`) (т.к. он больше).

### naive-prefix
Наивный алгоритм вычисления префикс-функции.

**Псевдокод:**
```
for (строка)                    // O(n)
	for (подстрока)             // O(n)
		if (префикс == суффикс) // O(n)
```

**Сложность по времени:** `O(n^3)`

### linear-time
Алгоритм вычисления вектора длин значений префикс-функции за линейное время.

**Шаги алгоритма:**
1) Заводим вектор `DFL` - вектор длин значений префикс-функции, `DFL[1] = 0` (для строчки длины `1`, собственный префикс-суффикс - это пустая строка).
2) Итерируемся по строке `s`.
3) Текущую подстроку `s[1:i]` разделяем на: подстроку `s[1:i-1]` и символ `s[i]`.
4) Смотрим на значение префикс-функции для `s[1:i-1]`: `k = DFL[i-1]` `P(s[1:i-1]) = s[1:k]`
	- если `k == 0`: `DFL[i] = 0`;
	- если `s[k+1] == s[i]`, то: `DFL[i] = k+1`;
	- иначе: пользуемся **Леммой-1** и итерируемся по префиксам-суффиксам назад: 
		- пока `p[k+1] != p[i] && k > 0`: `k = PFL[k]`;
		- если `p[k+1] == p[i]`: `PFL[i] = k+1`; 
		- иначе: `PFL[i] = 0`

![[Pasted image 20250604234732.png]]
![[Pasted image 20250604235322.png]]

**Проблема сложности:** сложно посчитать число "откатов" (не очевидно).

**Оценка потенциального числа откатов:**
Каждый раз значение в массиве `DFL` растет не более чем на `1` (т.к. при возрастании суффикса строки на `1`, значение префикс-функции не может увеличиться более чем на `1`).

Следовательно, число раз, когда значение префикс-функции может увеличиться - не более `N` раз, где `N` - длина строки, для которой подсчитывается префикс-функция.

Для "откатов" нужен рост. Также "откат" уменьшит значение префикс-функции в худшем случае только на `1`.

Таким образом, может быть не более чем `N` подъемов и `N` падений. Значит, сложность вычисления вектора длин значений префикс-функции - линейная.

# usage
- Поисковики.
- Биологи (геном).

# complexity
**naive-mathcing:**
- **По времени:** `O(m * (n - m + 1))` (`n - m + 1` мест в тексте,  куда можно приложить шаблон размера  `m`)
- **По памяти:** `O(n + m)` (`n` - длина текста, `m` - шаблона)

**kmp-algorithm:**
- **По времени:** `O(n + m)` (`n` - длина текста (нужно пройтись по нему), `m` - длина шаблона (необходимо вычислить вектор длин значений префикс-функции))
- **По памяти:** `O(n + m)` (для хранения двух строк и вектора длин значений префикс-функции)

# content
- [lecture](https://youtu.be/kIsPv5XRJgU?si=Tc1SeDQVnSJiJTS0)