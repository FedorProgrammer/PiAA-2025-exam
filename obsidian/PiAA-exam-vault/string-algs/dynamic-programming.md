# info
1) [algorithm](#algorithm)
	- [fibonacci-numbers](##fibonacci-numbers)
	- [maximum-increasing-subsequence](##maximum-increasing-subsequence)
	- [matrix-multiplication-order](##matrix-multiplication-order)
	- [editorial-distance](##editorial-distance)
		- [levenshtein-distance](###levenshtein-distance)
		- [fisher-wagner-algorithm](###fisher-wagner-algorithm)
2) [usage](#usage)
3) [complexity](#complexity)
4) [content](#content)

# algorithm
Динамическое программирование.

**Особенность алгоритма:**
Взгляд на задачу через последовательность рекуррентных подзадач. Если ответ получен в виде рекуррентной формулы, то задачу можно быстро свести к динамическому программированию.

## fibonacci-numbers
Задача о вычислении чисел Фибоначчи.

**Формулировка:**
Необходимо вычислить `n`-ое число Фибоначчи.

**Решение через рекурсию:**
```Python
def f(n):
	if (n == 1) or (n == 2): return 1
	return f(n - 1) + f(n - 2)
```

**Минус:**
- **Дублирование вычислений:** повторное вычисление значений для чисел Фибоначчи.
  ![[Pasted image 20250601201955.png]]

**Решение через динамическое программирование:**
Т.к. существует рекуррентная формула: `f(n) = f(n-1) + f(n-2)` для любого `n > 2`, то:
```Python
def f(n):
    if n == 1 or n == 2: return 1

    arr = [1 for _ in range(n)]
    for i in range(2, n):
        arr[i] = arr[i - 2] + arr[i - 1]
    return arr[-1]
```

**Оптимизация:**
- Хранить не весь массив промежуточных значений, а только две ячейки для `f(n-2)` и `f(n-1)`:
```Python
def f(n):
    if n == 1 or n == 2: return 1
    
    arr = [1, 1]
    for i in range(2, n):
        arr[i % 2] = arr[(i - 2) % 2] + arr[(i - 1) % 2]
    return arr[0] if n % 2 == 1 else arr[1]
```

## maximum-increasing-subsequence
Поиск максимальной возрастающей подпоследовательности.

**Формулировка:**
Необходимо найти максимальную по длине (не обязательно подряд идущую) возрастающую подпоследовательность.

**Основная идея:**
Введем обозначения:
- `n` - длина исходной последовательности.
- `s` - исходная последовательность.
- `s[i]` - `i`-ый элемент исходной последовательности.
- `s(i)` - срез `s` до `i`-го элемента включительно.
- `L(i)` - максимальная длина возрастающей подпоследовательности в `s(i)` (начальное значение: `L(0) = 1`).

Тогда алгоритм разбивается на две части:
1) Построить таблицу длины `n`, в которой `i`-ый элемент равен `L(i)`. 
2) Использовать формулу: 
	```
	L(i) = 1 + max(L(j) if s[i] > s[j])
	```
Где `j` пробегает все целые значения от `0` до `i-1`.

**Пример:**
Исходная последовательность `s`: `5 2 8 6 3 6 9 7`.
Используя формулу для `L(i)`, заполняем таблицу:

| s\[i\] V s\[j\] | -   | 2 > - | 8 > 5 and 8 > 2 | 6 > 2 | 3 > 2 | 6 > 3 | 9 > 6 | 7 > 6 |
| --------------- | --- | ----- | --------------- | ----- | ----- | ----- | ----- | ----- |
| L(i)            | 1   | 1     | 2               | 2     | 2     | 3     | 4     | 4     |
| i               | 0   | 1     | 2               | 3     | 4     | 5     | 6     | 7     |

## matrix-multiplication-order
Задача о порядке перемножения матриц.

**Формулировка:**
Необходимо перемножить матрицы в том порядке, чтобы итоговое число операций было бы минимальным, т.е. нужно минимизировать стоимость умножения.

**Основная идея:**
Операция умножения последовательности матриц `A1...An` ассоциативна (но не коммутативная в общем виде). Тогда оптимальное перемножение последовательности матриц `A1...An` сводится к следующей подзадаче: оптимально перемножить все подпоследовательности `Ai...Aj` исходной последовательности `A1...An`.

**Введем обозначение:** `D(i, j)` - минимальное число операций, требующихся для перемножения матриц от `i` до `j` по индексу.

Заметим, что любая подпоследовательность `Ai...Aj` разбивается на перемножение матриц, полученных из подпоследовательностей `Ai...Ak` и `Ak+1...Aj` для  некоторого `i <= k <= j`.

Таким образом, подзадача оптимального перемножения подпоследовательности `Ai...Aj` свелось к нахождению такого оптимального `k`.

Получаем следующую рекуррентную формулу:
```
D(i, j) = min(D(i, k) + D(k + 1, j) + m_(i-1) * m_k * m_j)
```
Где `k` пробегает все целые значения от `i` до `j`.

**Объяснение формулы:**
- Результатом перемножения `Ai...Ak` будет матрица размера `(m_(i-1) x m_k)`: `m_(i-1)`, т.к. изначальная последовательность `A1...Ai-1Ai...An` должна содержать такие матрицы, что перемножение любых двух соседних возможно, т.е. возможно перемножение матриц `Ai-1Ai` (число строк `Ai` равняется высоте `Ai-1`).
- Результатом перемножения `Ak+1...Aj` будет матрица размера `(m_k x m_j)`.
- Множитель `m_(i-1) * m_k * m_j` вылезает из итогового перемножения двух матриц размера `(m_(i-1) x m_k)` и `(m_k x m_j)`: чтобы получить итоговый результат `D(i, j)` необходимо перемножить матрицы, полученные из произведений `Ai...Ak` и `Ak+1...Aj`.

![[Pasted image 20250602000025.png]]

## editorial-distance
Задача нахождения редакционного расстояния.

**Формулировка:**
Найти такое минимальное число односимвольных операций (вставки, удаления, замены), необходимых для превращения одной строки в другую.

Каждая односимвольная операция имеет определенную стоимость.
### levenshtein-distance
Решение задачи редакционного расстояния рекурсивными методами.

Расстояние Левенштейна использует частный случай стоимости односимвольных операций: все стоят 1.

**Основная идея:**
`D(a, b)` - расстояние Левенштейна для двух строк a и b:
1) `D(a, b) = |a|`, если `|b| == 0`
2) `D(a, b) = |b|`, если `|a| == 0`
3) `D(a, b) = D(tail(a), tail(b))`, если `a[0] == b[0]`
4) `D(a, b) = 1 + min(D(tail(a), b), D(a, tail(b)), D(tail(a), tail(b)))`
Где `tail(a)`, `tail(b)` - часть строки за исключением первого символа.

### fisher-wagner-algorithm
Решение задачи редакционного расстояния методами динамического программирования.

**Основная идея:**
Построение матрицы размера `(|s1| + 1) x (|s2| + 1)` и заполнения ее элементов на основе рекуррентной формулы. Чтобы не вычислять расстояние Левенштейна много раз для одних и тех же строк (через стандартную рекуррентную формулу для расстояния Левенштейна) мы сохраняем вычисленные значения в матрице.

**Рекуррентная формула:**
`D[i, j]` - элемент матрицы (превращаем `s1` в `s2`):
1) `D[i, j] = 0`, если `i == 0` и `j == 0`.
2) `D[i, j] = i * dcost`, если `j == 0` и `i > 0` (удаляем `s1`).
3) `D[i, j] = j * icost`, если `i == 0` и `j > 0` (добавляем до `s2` пустую `s1`).
4) `D[i, j] = min(D[i, j - 1] + icost, D[i - 1, j] + dcost, D[i - 1, j - 1] + rcost)`, если `i > 0` и `j > 0`
Где: 
- Индексация строк в матрице начинается с единицы
- `D[i, j] = D(s1[:i+1], s2[:j+1])`
- `D(s1, s2) = D[N, M]`

**Оптимизация:** использование одной строки вместо матрицы для хранения стоимости изменений.

# usage
- Классические алгоритмические задачи: задача о рюкзаке, нахождение подпоследовательностей.
- Теория графов: алгоритмы поиска кратчайших путей (Беллман-Форд), задача коммивояжёра (для небольшого числа городов).
- Компьютерная графика и распознавание образов: сегментация изображений, распознавание контуров.
- Теория игр: определение оптимальных стратегий в играх с полной информацией.

# complexity
**fibonacci-numbers:**
- **По времени:** `O(N)` (после оптимизаций)
- **По памяти:** `O(1)` (после оптимизаций)

**maximum-increasing-subsequence:**
- **По времени:** `O(N^2)` (для `i`-го элемента последовательности перебираем `i-1` элемент)
- **По памяти:** `O(N)` (для хранения последовательности и таблицы)

**matrix-multiplication-order:**
ДАННУЮ ОЦЕНКУ НЕ ДАВАЛИ!
- **По времени:** `O(N^3)` (`N^2` ячеек таблицы, для которых нужно сделать не более чем `N` вызовов (когда пробегаемся `k` от `i` до `j`))
- **По памяти:** `O(N^2)` (т.к. создаем таблицу (NxN))

**fisher-wagner:**
- **По времени:** `O(N^2)` (`N^2` клеток таблицы, для которых подсчитываем значение за `O(1)`)
- **По памяти:** `O(min(N, M))` (после оптимизаций)

# content
- [matrix-multiplication-order](https://youtu.be/NhllzsvscRA?si=XSobndEReLjQzk_a)
- [editorial-distance](https://youtu.be/4TgAdLQ9oVY?si=ovsaFKndQ-EVqEw3)