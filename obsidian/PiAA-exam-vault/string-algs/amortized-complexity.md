# info
1) [algorithm](#algorithm)
	- [vector](##vector)
	- [unordered_set](##unordered_set)
2) [usage](#usage)
3) [complexity](#complexity)
4) [content](#content)

# algorithm
Амортизационная сложность.

Способ анализа сложности операции, когда не все операции в серии имеют одинаковую (низкую) сложность, но средняя стоимость одной операции в наихудшем случае для любой последовательности из N операций оказывается низкой.

Некоторые операции иногда выполняют дорогую работу (например, переаллокацию памяти), которая "оплачивает" несколько последующих дешевых операций.

**Способ подсчета:**
Суммарная сложность всех N операций делится на N. Результат - сложность одной операции в среднем по наихудшей последовательности.

**Примечание:**
Гарантия дается для последовательности операций, а не для каждой отдельной. Отдельная операция может быть дорогой, но благодаря ей следующие будут дешевыми.

## vector
Пример для `std::vector`.

**Отдельная операция:** в большинстве случаев добавление элемента в конец вектора (`push_back`) - это `O(1)` (просто записать элемент в заранее выделенную память).

**Последовательность операций:** когда вектор заполняется на половину, следующая операция `push_back` должна:
- Выделить новый блок памяти большего размера (обычно в 2 раза больше старого).
- Скопировать (или переместить) все существующие элементы из старого блока в новый.
- Уничтожить старые объекты и освободить старую память.
- Добавить новый элемент.

**Подсчет сложности последовательных операций:**
- Для `N` элементов `logN` переаллокаций. 
- `i`-ая аллокация - `O(2^i)` перемещений элементов.

Следовательно, за `N` операций добавления: `1 + 2 + 4 + ... + 2^logN` перемещений.
`(2^logN - 1) / (2 - 1) = N - 1` ([формула](https://foxford.ru/wiki/matematika/summa-i-raznost-vysokih-stepeney?srsltid=AfmBOooVkF4JsuZPIRIntIjRiKjyKjSOrJs4RMrLoA_PjNw479-SoY2A&utm_referrer=https%3A%2F%2Fwww.google.com%2F) разности `n`-ых степеней)

**Итог:**
- `N` операций добавления - `O(N)` действий (перемещений, добавлений).
- Амортизационная сложность - `O(N / N) = O(1)`. 

## unordered_set
Пример для `std::unordered_set` (хеш-таблица с цепочками через связные списки).

**Отдельная операция:** большинство операций insert выполняются за `O(1)` (просто добавить элемент в цепочку корзины).

**Последовательность операций:** если коэффициент заполнения превышает единицу, то нужно:
- Выделить новый массив цепочек: Количество корзин увеличивается (обычно до ближайшего простого числа, большего чем `2 * chain_count()`).
- Перевычислить индексы для всех элементов (`O(n)`).
- Переместить элементы в новые цепочки (`O(n)`).
- Освободить старую память: удаляются все старые корзины и связанные с ними цепочки коллизий.
- Вставить новый элемент.

Аналогично получаем: 
- `O(n)` - сложность для заполнения `n` элементами.
- `O(1)` - амортизационная сложность.

# usage
- Вычисление времени работы основных операций структур данных.

# complexity
**std::vector:**
- **По времени:** 
	- Единичная операция вставки - `O(1)`.
	- Множественная операция вставки - `O(N)`.
	- Амортизационная сложность вставки - `O(1)`.

**std::unordered_set:**
- **По времени:** 
	- Единичная операция вставки - `O(1)`.
	- Множественная операция вставки - `O(N)`.
	- Амортизационная сложность вставки - `O(1)`.

# content
Конспект лекции.